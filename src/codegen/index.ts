import { GlobalContext, OpenAPI3, OpenAPITSOptions, Subschema } from "./types"
import type { Readable } from "node:stream"
import { URL } from "node:url"
import load, { resolveSchema, VIRTUAL_JSON_URL } from "./load"
import { transformSchema } from "./transform/index"
import transformMediaTypeObject from "./transform/media-type-object"
import transformOperationObject from "./transform/operation-object"
import transformParameterObject from "./transform/parameter-object"
import transformRequestBodyObject from "./transform/request-body-object"
import transformResponseObject from "./transform/response-object"
import transformSchemaObject from "./transform/schema-object"
import { error, escObjKey, getDefaultFetch, getEntries } from "./utils"
export * from "./types" // expose all types to consumers
import prettier from "prettier"
import Path from "node:path"
import fs from "node:fs"
import { treatSchema } from "./generate/treat"
import { OpenAPIManifold } from "./generate/types"
import { generateApisFiles } from "./generate"

const EMPTY_OBJECT_RE = /^\s*\{?\s*\}?\s*$/

export const COMMENT_HEADER = `/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

`

export type ApiLibraryBundle = { [filename: string]: string }

/**
 * This function is the entry to the program and allows the user to pass in a remote schema and/or local schema.
 * The URL or schema and headers can be passed in either programmatically and/or via the CLI.
 * Remote schemas are fetched from a server that supplies JSON or YAML format via an HTTP GET request. File based schemas
 * are loaded in via file path, most commonly prefixed with the file:// format. Alternatively, the user can pass in
 * OpenAPI2 or OpenAPI3 schema objects that can be parsed directly by the function without reading the file system.
 *
 * Function overloading is utilized for generating stronger types for our different schema types and option types.
 *
 * @param {string} schema Root Swagger Schema HTTP URL, File URL, and/or JSON or YAML schema
 * @param {SwaggerToTSOptions<typeof schema>} [options] Options to specify to the parsing system
 * @return {Promise<string>}  {Promise<string>} Parsed file schema
 */
async function generateApiLibrary(
  schema: string | URL | OpenAPI3 | Readable,
  options: OpenAPITSOptions = {} as Partial<OpenAPITSOptions>
): Promise<ApiLibraryBundle> {

  const ctx: GlobalContext = {
    additionalProperties: options.additionalProperties || false,
    alphabetize: options.alphabetize || false,
    defaultNonNullable: options.defaultNonNullable || false,
    discriminators: {},
    transform: options && typeof options.transform === "function" ? options.transform : undefined,
    postTransform: options && typeof options.postTransform === "function" ? options.postTransform : undefined,
    immutableTypes: options.immutableTypes || false,
    operations: {},
    pathParamsAsTypes: options.pathParamsAsTypes || false,
    silent: options.silent || false,
    supportArrayLength: options.supportArrayLength || false,
  }

  // note: we may be loading many large schemas into memory at once; take care to reuse references without cloning
  const isInlineSchema = typeof schema !== "string" && schema instanceof URL == false

  // 1. load schema (and subschemas)
  const allSchemas: { [id: string]: Subschema } = {}
  const schemaURL: URL = typeof schema === "string" ? resolveSchema(schema) : (schema as URL)
  await load(schemaURL, {
    ...ctx,
    auth: options.auth,
    schemas: allSchemas,
    rootURL: isInlineSchema ? new URL(VIRTUAL_JSON_URL) : schemaURL, // if an inline schema is passed, use virtual URL
    urlCache: new Set(),
    httpHeaders: options.httpHeaders,
    httpMethod: options.httpMethod,
    fetch: options.fetch ?? getDefaultFetch(),
  })

  // 1. basic validation
  for (const k of Object.keys(allSchemas)) {
    const subschema = allSchemas[k]
    if (typeof (subschema.schema as any).swagger === "string") {
      error("Swagger 2.0 and older no longer supported. Please use v5.")
      process.exit(1)
    }
    if (subschema.hint === "OpenAPI3" && typeof subschema.schema.openapi === "string") {
      if (parseInt(subschema.schema.openapi) !== 3) {
        error(`Unsupported OpenAPI version "${subschema.schema.openapi}". Only 3.x is supported.`)
        process.exit(1)
      }
    }
  }

  // 2. generate raw output
  const output: string[] = []

  // 2a. Start file, inject custom code (if any)
  if (options && "commentHeader" in options) {
    if (options.commentHeader) output.push(options.commentHeader)
  } else {
    output.push(COMMENT_HEADER)
  }

  // 2b. options.inject
  if (options.inject) output.push(options.inject)

  const manifold = new OpenAPIManifold()
  {
    const schema = allSchemas["."].schema as OpenAPI3
    treatSchema(schema as OpenAPI3, manifold.getApi(schema.info?.title))
  }

  // 2c. root schema
  const rootTypes = transformSchema(allSchemas["."].schema as OpenAPI3, ctx)
  for (const k of Object.keys(rootTypes)) {
    if (rootTypes[k] && !EMPTY_OBJECT_RE.test(rootTypes[k])) {
      output.push(
        options.exportType ? `export type ${k} = ${rootTypes[k]};` : `export interface ${k} ${rootTypes[k]}`,
        ""
      )
    } else {
      output.push(`export type ${k} = Record<string, never>;`, "")
    }
    delete rootTypes[k]
    delete allSchemas["."] // garbage collect, but also remove from next step (external)
  }

  // 2d. external schemas (subschemas)
  const externalKeys = Object.keys(allSchemas) // root schema (".") should already be removed
  if (externalKeys.length) {
    output.push(options.exportType ? "export type external = {" : "export interface external {", "")
    externalKeys.sort((a, b) => a.localeCompare(b, "en", { numeric: true })) // sort external keys because they may have resolved in a different order each time
    for (const subschemaID of externalKeys) {
      const subschema = allSchemas[subschemaID]
      const key = escObjKey(subschemaID)
      const path = `${subschemaID}#`
      let subschemaOutput = ""
      switch (subschema.hint) {
        case "OpenAPI3": {
          const subschemaTypes = transformSchema(subschema.schema, ctx)
          if (!Object.keys(subschemaTypes).length) break
          output.push(`${key}: {`, "")
          for (const [k, v] of getEntries(subschemaTypes, options.alphabetize)) {
            if (EMPTY_OBJECT_RE.test(v)) output.push(`${escObjKey(k)}: Record<string, never>;`)
            else output.push(`${escObjKey(k)}: {${v};`, "};")
          }
          output.push("}")
          break
        }
        case "MediaTypeObject": {
          subschemaOutput = transformMediaTypeObject(subschema.schema, { path, ctx })
          break
        }
        case "OperationObject": {
          subschemaOutput = transformOperationObject(subschema.schema, { path, ctx })
          break
        }
        case "ParameterObject": {
          subschemaOutput = transformParameterObject(subschema.schema, { path, ctx })
          break
        }
        case "RequestBodyObject": {
          subschemaOutput = transformRequestBodyObject(subschema.schema, { path, ctx })
          break
        }
        case "ResponseObject": {
          subschemaOutput = transformResponseObject(subschema.schema, { path, ctx })
          break
        }
        case "SchemaObject": {
          subschemaOutput = transformSchemaObject(subschema.schema, { path, ctx })
          break
        }
        default: {
          error(`Could not resolve subschema ${subschemaID}. Unknown type "${(subschema as any).hint}".`)
          process.exit(1)
        }
      }
      if (subschemaOutput && !EMPTY_OBJECT_RE.test(subschemaOutput)) {
        output.push(`${key}: ${subschemaOutput}`)
      }
      delete allSchemas[subschemaID]
    }
    output.push(`}${options.exportType ? ";" : ""}`, "")
  } else {
    output.push(`export type external = Record<string, never>;`, "")
  }

  // 3. operations (only get fully built after all external schemas transformed)
  if (Object.keys(ctx.operations).length) {
    output.push(options.exportType ? "export type operations = {" : "export interface operations {", "")
    for (const k of Object.keys(ctx.operations)) {
      output.push(`${escObjKey(k)}: ${ctx.operations[k]};`)
    }
    output.push(`}${options.exportType ? ";" : ""}`, "")
  } else {
    output.push(`export type operations = Record<string, never>;`, "")
  }

  // 4a. OneOf type helper (@see https://github.com/Microsoft/TypeScript/issues/14094#issuecomment-723571692)
  output.splice(
    1,
    0,
    "import { Without, XOR, OneOf, WithRequired } from \"@ewam/openapi-helpers\"",
    ""
  )

  const output_files = {}

  let types_mts = output.join("\n")
  try {
    types_mts = prettier.format(types_mts, {
      printWidth: 120,
      tabWidth: 2,
      trailingComma: "all",
      parser: "typescript",
    })
  }
  catch (e) {
    console.error(e)
  }
  output_files["types.ts"] = types_mts

  {
    Object.assign(output_files, generateApisFiles(manifold.apis[0]))
  }

  return output_files
}

async function makeApiDirectory(output: string, bundle: ApiLibraryBundle): Promise<void> {
  for (const filename in bundle) {
    let outputFilePath = Path.resolve(output, filename); // note: may be directory
    const isDir = fs.existsSync(outputFilePath) && fs.lstatSync(outputFilePath).isDirectory();
    if (isDir) {
      error(`Could not create output file "${outputFilePath}".`);
      process.exit(1);
    }
    fs.mkdirSync(Path.dirname(outputFilePath), { recursive: true })
    fs.writeFileSync(outputFilePath, bundle[filename], "utf8");
  }
}

export default {
  generateApiLibrary,
  makeApiDirectory,
}
